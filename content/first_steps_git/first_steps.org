# -*- ispell-dictionary: "english" -*-
#+AUTHOR: Martin Richter
#+TITLE: Examples for Using git
#+EMAIL: martin.richter@nottingham.ac.uk

#+OPTIONS: <:nil d:nil timestamp:t ^:nil tags:nil toc:nil num:nil
#+STARTUP: fninline overview inlineimages

#+SETUPFILE: "./reveal_config.org"
# Weird -- why do we have to repeat these here?
# If they are not here, the style is not picked up correctly!
#+html: <link rel="stylesheet" href="file:///usr/local/share/martin/reveal.js/plugin/highlight/solarized-light.css">
#+html: <style type="text/css" media="screen"> .reveal pre code { max-height: 100%; font-size: 0.8em } </style>

# This makes the inline code easier to read but messes with the color code in general
# #+html: <style type="text/css" media="screen"> .reveal code { color: darkblue } </style>

* Examples for Using ~git~

  #+begin_quote
  In order to keep the examples programming language agnostic, we will
  mimic writing a small text / collection of quotes.
  #+end_quote

** COMMENT Technicalities for Exporting This Document

   To export: ~C-e R R~ to export as reveal.js presentation.
   #+BEGIN_SRC emacs-lisp
     (org-reveal-export-to-html)
   #+END_SRC

   Alternatively:

   From: [[https://stackoverflow.com/a/65428989/2959456]]
   Drawback: No links between the files for navigation
   #+begin_src emacs-lisp
     (defun my-org-export-each-level-3-headline-to-html (&optional scope)
       (interactive)
       (org-map-entries
        (lambda ()
          (let* ((title (car (last (org-get-outline-path t))))
                 (dir (file-name-directory buffer-file-name))
                 (filename (concat dir title ".html")))
            (org-narrow-to-subtree)
            (org-html-export-as-html)
            (write-file filename)
            (kill-current-buffer)
            (widen)))
        "LEVEL=3" scope))
   #+end_src

** Configuration and First Steps
*** Preliminary: Setup Local Configuration

    - Either edit =~/.gitconfig= to at least contain
      #+begin_src conf
        [user]
                name = Martin Richter
                email = martin.richter@nottingham.ac.uk
      #+end_src

    - Or use ~git~ to create this configuration for you
      #+begin_src shell-script
        git config --global --add user.name "Martin Richter"
        git config --global --add user.email "martin.richter@nottingham.ac.uk"
      #+end_src

    - While we are at it, we might set up a few more bits which can come
      handy later:
      #+begin_src conf
        [color]
                ui = true
      #+end_src

*** Creating a Local Repository

    Create some description of what we want to do
    #+begin_src shell-script
      cd ~/       # go to whereever you want to do your work
      mkdir letter_collection
      cd letter_collection
      cat << EOF > README.md
      Repository contains drafts of letters
      EOF
    #+end_src

    Somewhat important: Configuration relevant for this repository only
    is in ~.git/config~.

    #+begin_src shell-script
      # create the repository
      git init
      # Initialised empty Git repository in /home/.../letter_collection/.git/
      git add README.md
      git commit -m 'initial commit, add README.md'
      # [master (root-commit) 24bfc05] initial commit, add README.md
      #  1 file changed, 1 insertion(+)
      #  create mode 100644 README.md
      # If you want, you can rename the branch to something else
      git branch -M main
    #+end_src

#+REVEAL: split:t
    Now what did this do? Let's have a look around!
    /Note git is nothing scary - just a folder!/

    Besides our file ~README.md~ there is a folder ~.git~ with
    various bits in it. All information will be stored here.
    Usually no need to enter it.

    #+REVEAL_HTML: <div style="width: 100%">
    #+REVEAL_HTML: <div class="column" style="float:left; width: 50%">
    #+begin_src shell-script
      tree -aCI '*sample'
      # .
      # ├── .git
      # │   ├── branches
      # │   ├── COMMIT_EDITMSG
      # │   ├── config
      # │   ├── description
      # │   ├── HEAD
      # │   ├── hooks
      # │   ├── index
      # │   ├── info
      # │   │   └── exclude
      # │   ├── logs
      # │   │   ├── HEAD
      # │   │   └── refs
      # │   │       └── heads
      # │   │           └── main
      # │   │
    #+end_src
    #+REVEAL_HTML: </div>

    #+REVEAL_HTML: <div class="column" style="float:right; width: 50%">
    #+begin_src shell-script
      # │   │
      # │   ├── objects
      # │   │   ├── 1f
      # │   │   │   └── e5b7bc904e286e2740d8b40e9cd0b18309c743
      # │   │   ├── 20
      # │   │   │   └── 273694fcbe9537e321143b6427f07e5f0aad68
      # │   │   ├── 22
      # │   │   │   └── 8933b64e66dbbca9adb5e8e17810381eca6c5b
      # │   │   ├── info
      # │   │   └── pack
      # │   └── refs
      # │       ├── heads
      # │       │   └── main
      # │       └── tags
      # └── README.md
    #+end_src
    #+REVEAL_HTML: </div>
    #+REVEAL_HTML: </div>

*** Finding out About the State of the Repository

    We will use these later:

    - What is the status of the repository like?
      #+begin_src shell-script
        git status
      #+end_src

    - What happened so far?
      #+begin_src shell-script
        git log
      #+end_src

    - And to see last commit
      #+begin_src shell-script
        git show
      #+end_src

#+REVEAL: split:t
**** Customizations to Help Your Daily Use

     #+begin_src shell-script
       git diff --color-words
       # or
       git show --color-words
       # or
       git log --graph --all --pretty=format:'%Cred%h%Creset - %Cgreen(%cr)%Creset %s%C(yellow)%d%Creset' --abbrev-commit --date=relative --decorate
     #+end_src

     Use ~.gitconfig~ to define an /alias/
     #+begin_src conf
      [alias]
              wdiff = diff --color-words
              wshow = show --color-words
              graph = log --graph --all --pretty=format:'%Cred%h%Creset - %Cgreen(%cr)%Creset %s%C(yellow)%d%Creset' --abbrev-commit --date=relative --decorate

      [init]
              defaultBranch = main     # Introduced with git 2.28.0

      [merge]
              conflictstyle = diff3    # gives more context on conflicts
     #+end_src

*** Adding New Files

    To add new files, two steps are necessary:

    1. Create a new file
       #+begin_src shell-script
         mkdir content
         echo "# Chapter 1" > content/chapter1.md
         echo "# Chapter 2" > content/chapter2.md
       #+end_src

       What does git think about this new file lying around?
       #+begin_src shell-script
         git status
         # On branch main
         # Untracked files:
         #   (use "git add <file>..." to include in what will be committed)
         #
         #       content/
         #
         # nothing added to commit but untracked files present (use "git add" to track)
       #+end_src

    2. Add the file to the staging are (/index/)
       #+begin_src shell-script
         git add content/chapter1.md
       #+end_src

#+REVEAL: split:t
    3. [@3] Check the staging area
       #+begin_src shell-script
         git status
         # On branch main
         # Changes to be committed:
         #   (use "git reset HEAD <file>..." to unstage)
         #
         #       new file:   content/chapter1.md
         #
         # Untracked files:
         #   (use "git add <file>..." to include in what will be committed)
       #+end_src
       One file is registered for the next commit, the other one is not.

    4. Commit the file to repository

       After all new files have been ~git add'ed~, commit. Add a descriptive message
       #+begin_src shell-script
         git commit -m 'add stub for chapter 1'
         # [main 51fe4ad] add stub for chapter 1
         #  1 file changed, 1 insertion(+)
         #  create mode 100644 content/chapter1.md
         git status
         # On branch main
         # Untracked files:
         #   (use "git add <file>..." to include in what will be committed)
         #
         #       content/chapter2.md
         #
         # nothing added to commit but untracked files present (use "git add" to track)
       #+end_src

*** Changing Existing Files

    Let us assume we are adding text to chapter 1.
    #+begin_src shell-script
      echo '\nCognito ergo sum' >> content/chapter1.md
      echo '\nIn dubio pro reo.' >> content/chapter1.md
    #+end_src

    To see local changes:
    #+begin_src shell-script
      git diff
    #+end_src
    yields the following diff:
    #+begin_src diff
 diff --git a/content/chapter1.md b/content/chapter1.md
 index b743fda..ef9b254 100644
 --- a/content/chapter1.md
 +++ b/content/chapter1.md
 @@ -1 +1,5 @@
  # Chapter 1
 +
 +Cognito ergo sum
 +
 +In dubio pro reo.
    #+end_src

#+REVEAL: split:t
    To register them, use the ~git add~ / ~git commit~ again
    #+begin_src shell-script
      git add content/chapter1.md
      git commit -m 'add latin phrases to chapter 1'
      # [main 53c71a5] add latin phrases to chapter 1
      #  1 file changed, 4 insertions(+)
      git log
      # commit 53c71a5d2209d59d9d8fcd5bc43e428e49d6819a (HEAD -> main)
      # Author: Martin Richter <martin.richter@nottingham.ac.uk>
      # Date:   Fri Mar 26 15:43:59 2021 +0000
      #
      #     add latin phrases to chapter 1
      #
      # commit 51fe4ad4224e93846eddb56eab9648dc57e04dde
      # Author: Martin Richter <martin.richter@nottingham.ac.uk>
      # Date:   Fri Mar 26 15:33:12 2021 +0000
      #
      #     add stub for chapter 1
      #
      # commit db300197450d4c9f9f165b347f4ec4708876a284
      # Author: Martin Richter <martin.richter@nottingham.ac.uk>
      # Date:   Fri Mar 26 11:05:41 2021 +0000
      #
      #     initial commit, add README.md
      #
      git graph
      # * 53c71a5 - (63 seconds ago) add latin phrases to chapter 1 (HEAD -> main)
      # * 51fe4ad - (12 minutes ago) add stub for chapter 1
      # * db30019 - (4 hours ago) initial commit, add README.md
    #+end_src

*** Committing and Commit Messages

    In order to get the most out of the history, try to make
    - Commits small and on one mental subject
    - Conform with a simple format rule:
      1. First line not more than _50_ characters
      2. If more explanation needed, add an _empty line_ and add more text

         this time not more than _72_ characters.

      This will keep all messages in a format that is nicely displayed
      by all tools.

#+REVEAL: split:t
    Check by having a look at ~gitk~.
    #+name: fig:gitk_example_commit_msgs
    #+caption: Using ~gitk~ to display commit messages.
    [[file:figures/gitk_example_010_commit_msg.png]]

#+REVEAL: split:t
**** Amend the Last Commit

     Sometimes you realize that you missed something in the last commit
     or commit message.

     In this case
     #+begin_src shell-script
       echo '\nQuidquid latine dictum sit altum videtur.' >> content/chapter1.md
       git add content/chapter1.md
       git commit --amend   # if you don't want to change message, you can add `-C HEAD`
       # [main e5d7d2b] add latin phrases to chapter 1
       #  Date: Fri Mar 26 15:43:59 2021 +0000
       #  1 file changed, 6 insertions(+)
     #+end_src
     will allow you to change the last commit.

     Note that this changed history:
     #+begin_src shell-script
       git graph
       # * e5d7d2b - (2 minutes ago) add latin phrases to chapter 1 (HEAD -> main)
       # * 51fe4ad - (28 minutes ago) add stub for chapter 1
       # * db30019 - (5 hours ago) initial commit, add README.md
     #+end_src

     Be aware: Do not do this if already published (pushed - see later)

#+REVEAL: split:t
     This is again a good time to also check with ~gitk~.

     #+name: fig:gitk_example_commit_msgs
     #+caption: Using ~gitk~ to display commit messages.
     [[file:figures/gitk_example_010_commit_msg.png]]

*** Ignoring Files

    Some files should not be part of the repository but also not
    visible git ignore and ~.gitignore~, most prominently automatically
    generated backup files.

    #+begin_src shell-script
      touch content/chapter1.log     # assume this is automatically generated
      git status
      # On branch main
      # Untracked files:
      #   (use "git add <file>..." to include in what will be committed)
      #
      #  content/chapter1.log
      #  content/chapter2.md
      echo content/chapter1.log > .gitignore
      git add .gitignore
      git commit -m 'add gitignore file'
      # [main 2218517] add gitignore file
      #  1 file changed, 1 insertion(+)
      #  create mode 100644 .gitignore
      git status
      # On branch main
      # Untracked files:
      #   (use "git add <file>..." to include in what will be committed)
      #
      #  content/chapter2.md
      #
      # nothing added to commit but untracked files present (use "git add" to track)
      tree
      # .
      # ├── content
      # │   ├── chapter1.log
      # │   ├── chapter1.md
      # │   └── chapter2.md
      # └── README.md
    #+end_src

*** Creating and using a Branch

    Allow for work on different aspects without interference

    #+begin_src shell-script
      git branch chapter2
      git graph
      # * 2218517 - (4 minutes ago) add gitignore file (HEAD -> main, chapter2)
      # * e5d7d2b - (11 minutes ago) add latin phrases to chapter 1
      # * 51fe4ad - (37 minutes ago) add stub for chapter 1
      # * db30019 - (5 hours ago) initial commit, add README.md
    #+end_src

    Assume we would continue on chapter 1 now ...
    #+begin_src shell-script
      echo '\nPer aspera ad astra' >> content/chapter1.md
      git add content/chapter1.md
      git commit -m 'continue work on chapter 1'
      # [main 11cf9a1] continue work on chapter 1
      #  1 file changed, 2 insertions(+)
      git graph
      # * 11cf9a1 - (47 seconds ago) continue work on chapter 1 (HEAD -> main)
      # * 2218517 - (6 minutes ago) add gitignore file (chapter2)
      # * e5d7d2b - (13 minutes ago) add latin phrases to chapter 1
      # * 51fe4ad - (39 minutes ago) add stub for chapter 1
      # * db30019 - (5 hours ago) initial commit, add README.md
    #+end_src

    The /chapter2/ marker stayed where we created it!
    #+begin_src shell-script
      git checkout chapter2
      # Switched to branch 'chapter2'
      tail -2 content/chapter1.md       # shows last two lines of file
      #
      # Quidquid latine dictum sit altum videtur.
    #+end_src

#+REVEAL: split:t
    What happens if we start working here?
    #+begin_src shell-script
      git add content/chapter2.md
      git commit -m 'add emtpy stub for chapter2'
      # [chapter2 ddd7afd] add emtpy stub for chapter2
      #  1 file changed, 1 insertion(+)
      #  create mode 100644 content/chapter2.md
      git graph
      # * ddd7afd - (35 seconds ago) add emtpy stub for chapter2 (HEAD -> chapter2)
      # | * 11cf9a1 - (4 minutes ago) continue work on chapter 1 (main)
      # |/
      # * 2218517 - (8 minutes ago) add gitignore file
      # * e5d7d2b - (16 minutes ago) add latin phrases to chapter 1
      # * 51fe4ad - (42 minutes ago) add stub for chapter 1
      # * db30019 - (5 hours ago) initial commit, add README.md
    #+end_src

    See also with ~gitk --all~

    #+name: fig:gitk_branches
    #+caption: Different branches shown in GUI of ~gitk --all~.
    [[file:figures/gitk_example_020_two_branches.png]]

*** How to Search for Things

    Once you have done many commits, it might be hard to remember what
    you did when. Especially after you removed content.

    Let us assume we want to remove something from Chapter 1 again

    #+begin_src shell-script
      git branch chapter1 main   # create a new branch "chapter1" where "main" is
      git checkout chapter1
      # Switched to branch 'chapter1'
    #+end_src

    Let's replace one of the phrases with an alternative version
    #+begin_src shell-script
      sed -i 's/Cognito/Ludo/' content/chapter1.md
      git diff
    #+end_src
    The ~diff~ yields:
    #+begin_src diff
 diff --git a/content/chapter1.md b/content/chapter1.md
 index 674f79e..6017206 100644
 --- a/content/chapter1.md
 +++ b/content/chapter1.md
 @@ -1,6 +1,6 @@
  # Chapter 1

 -Cognito ergo sum
 +Ludo ergo sum

  In dubio pro reo.
    #+end_src

#+REVEAL: split:t
    Let us add this to the repository ...
    #+begin_src shell-script
      git add content/chapter1.md
      git commit -m 'change reason for being'
      # [chapter1 dcf2ce3] change reason for being
      #  1 file changed, 1 insertion(+), 1 deletion(-)
    #+end_src

    At this point, none of the files in the repository contains the word /Cognito/ anymore!
    #+begin_src shell-script
      find -name '*.md' -exec grep --color=always -nHi 'cognito' {} \;
      #  <no results>
      # Recommended on command line: if it is installed, use a tool like `ack` or `ripgrep`
      ack -i cognito
      #  <no results wither, of course>
    #+end_src

    But we can search for all commits which did introduce or delete it!
    #+begin_src shell-script
      git log --oneline -i -G "cognito"   # -i : ignore case, --oneline for brevity here
      # dcf2ce3 (HEAD -> chapter1) change reason for being
      # e5d7d2b add latin phrases to chapter 1
      git log --patch -i -G "cognito"     # To see what changed were done
    #+end_src

    *Take-home message*: Trust ~git~, once you have given something into
    its hands, it won't be lost!

*** Keeping an Overview - Using Tags

    While history evolves, you might want to remember specific states
    of your work, for example the state of the software used for the
    data submitted in a paper or when you went to a conference.

    This is what /tags/ are for: They allow you to memorize states of
    the repository more easily, maybe including a message:
    #+begin_src shell-script
      git tag -a -m 'First draft, a bit of content' v0.0.1
      git log --oneline
      # dcf2ce3 (HEAD -> chapter1, tag: v0.0.1) change reason for being
      # 11cf9a1 (main) continue work on chapter 1
    #+end_src
    Note how the first line now also features a ~tag: v0.0.1~.
    This will stay there, even if ~chapter1~ moves on:
    #+begin_src shell-script
      # add new content
      echo '\nPacta sunt servanda' >> content/chapter1.md
      # add the change to the index (-a) and commit
      git commit -a -m 'add latin phrase on keeping contracts'
      # check the log
      git log --oneline
      # fd6aadd (HEAD -> chapter1) add latin phrase on keeping contracts
      # dcf2ce3 (tag: v0.0.1) change reason for being
      # 11cf9a1 (main) continue work on chapter 1
    #+end_src

** Merging Conflicts

*** When Merges Occur
    When working on projects, might lead to /conflicts/. This can happen if
    - You work (alone or in teams) on separate branches to write / implement features
    - You work alone on different computers all with their own local copy.
      (E.g. one for your Laptop and one on the HPC / workstations)
    - When you work collaboratively with colleagues on a project.

    In order to make you familiar with /conflicts/ we will mimic the
    above cases locally so that you can follow the steps on a local
    installation. But for simplicity, we start with the first case
    using separate branches. While this seems a less likely to happen,
    it is the easier setup to explain conflicts and how to resolve
    them.

*** Conflicts Between Local Branches

    We can go back to either our /branch/ ~main~ or to the /tag/
    ~v0.0.1~ from above and start from there in order to create a
    simple conflict:
    #+begin_src shell-script
      git checkout -b chapter1_alternative v0.0.1
      # Switched to a new branch 'chapter1_alternative'
      git log --all --oneline    # --all to see `chapter1` as well here
      # fd6aadd (chapter1) add latin phrase on keeping contracts
      # dcf2ce3 (HEAD -> chapter1_alternative, tag: v0.0.1) change reason for being
      # ddd7afd (chapter2) add emtpy stub for chapter2
      # 11cf9a1 (main) continue work on chapter 1
    #+end_src
    Note how ~HEAD~ (that is the currently checked out version) now
    resides on ~chapter1_alternative~ which is at the position of our
    /tag/.

#+REVEAL: split:t
    Let us add some different content and commit this as well:
    #+begin_src shell-script
      echo '\nSic transit gloria mundi' >> content/chapter1.md
      git commit -a -m 'add phrase on how all glory of the world passes'
      git graph      # this uses the above alias for better readability
      # * 5521dc4 - (48 seconds ago) add phrase on how all glory of the world passes (HEAD -> chapter1_alternative)
      # | * fd6aadd - (6 minutes ago) add latin phrase on keeping contracts (chapter1)
      # |/
      # * dcf2ce3 - (2 weeks ago) change reason for being (tag: v0.0.1)
      # * 11cf9a1 - (2 weeks ago) continue work on chapter 1 (main)
      # | * ddd7afd - (2 weeks ago) add emtpy stub for chapter2 (chapter2)
      # |/
      # * 2218517 - (2 weeks ago) add gitignore file
      # * e5d7d2b - (2 weeks ago) add latin phrases to chapter 1
      # * 51fe4ad - (2 weeks ago) add stub for chapter 1
      # * db30019 - (2 weeks ago) initial commit, add README.md
    #+end_src

    We see that the history diverged just like it did before with
    ~chapter2~.

    But this time, we want to get both versions together into a proper
    ~chapter1~. This can be done using /merges/ or /rebases/.

#+REVEAL: split:t
**** Merging Conflicts

     When working with others, this is usually preferred as it keeps
     the history consistent. It comes with the benefit of usually
     being a bit simpler to do. The drawback is, that the resulting
     history of the repository is not linear.

#+REVEAL: split:t
     In order to update ~chapter1~ with the alternative version, we
     can do:
     #+begin_src shell-script
       git checkout chapter1
       # Switched to branch 'chapter1'
       git merge chapter1_alternative
       # Auto-merging content/chapter1.md
       # CONFLICT (content): Merge conflict in content/chapter1.md
       # Automatic merge failed; fix conflicts and then commit the result.
     #+end_src

     This tells us, that /git/ was not able to find a good way of
     combining the two versions. Simply put, it does not know what the
     combined, true story should be.

#+REVEAL: split:t
     Possibilities are

     - We keep both but which should go first?
     - Should one be removed? Which one?
     - Should both be removed?
     - Should something completely different go into the text?

     These different possibilities emphasize one of the basic rules of version control:
     #+begin_quote
     No technical tool for version control removes the necessity of communication!
     #+end_quote
     In the end you will have to talk to your colleagues about which
     of the solutions is the one you want!

#+REVEAL: split:t
***** Aborting a Merge

      Maybe you don't feel confident to merge the changes
      (e.g. because you don't know what a good resolution would
      be). You can abort a merge and go back to the state before you entered ~git merge ...~:
      #+begin_src shell-script
        git merge --abort     # you must not have altered content of files before that
        git log --oneline     # and we are back to where we were
        # fd6aadd (HEAD -> chapter1) add latin phrase on keeping contracts
        # dcf2ce3 (tag: v0.0.1) change reason for being
        # 11cf9a1 (main) continue work on chapter 1
      #+end_src

#+REVEAL: split:t
***** Resolving Conflicts using Merges

      If we go back to the above conflict state, i.e. by calling ~git
      merge chapter1_alternative~, then git will inform us about its
      struggle. It shows the following ~git status~ report:
      #+begin_src shell-script
        git status
        # On branch chapter1
        # You have unmerged paths.
        #   (fix conflicts and run "git commit")
        #   (use "git merge --abort" to abort the merge)
        #
        # Unmerged paths:
        #   (use "git add <file>..." to mark resolution)
        #
        #       both modified:   content/chapter1.md
        #
        # no changes added to commit (use "git add" and/or "git commit -a")
      #+end_src
      and it tells us what to do, namely to /fix conflicts/ and then to
      /run/ ~git commit~.

#+REVEAL: split:t
      Furthermore, ~git~ put some hints into the conflicting files:
      Run ~git diff~ to get:
      #+begin_src diff
 git diff
 diff --cc content/chapter1.md
 index fc5a306,0736795..0000000
 --- a/content/chapter1.md
 +++ b/content/chapter1.md
 @@@ -7,5 -7,5 +7,11 @@@ In dubio pro reo
   Quidquid latine dictum sit altum videtur.

   Per aspera ad astra
 ++<<<<<<< HEAD
  +
  +Pacta sunt servanda
 ++||||||| merged common ancestors
 ++=======
 +
 + Sic transit gloria mundi
 ++>>>>>>> chapter1_alternative
      #+end_src

      Let us go through these in a few steps.

#+REVEAL: split:t
      - Merged Common Ancestors :: The lines between ~|||||||~ and
        ~=======~ are where both versions came from - in this case
        here, it is empty because none of the two versions deleted a
        lines.

      - HEAD :: The lines on the top between ~<<<<<<<~ and ~|||||||~
        show the version of the branch we have currently checked out.
        Sometimes this is also referred to as /ours/.

      - other version :: The lines at the bottom between ~=======~ and
        ~>>>>>>>~ show the other version (here the branch
        ~chapter1_alternative~) we are trying to merge in, sometimes
        called /theirs/.

#+REVEAL: split:t
      To resolve the conflict, we have to edit the file and remove
      these markers. Let us assume, we are happy with the content

      #+begin_src shell-script
        tail -n 5 content/chapter1.md
        # Per aspera ad astra
        #
        # Pacta sunt servanda
        #
        # Sic transit gloria mundi
      #+end_src

      Note that the status still reads:
      #+begin_src shell-script
        git status
        # On branch chapter1
        # You have unmerged paths.
        #   (fix conflicts and run "git commit")
        #   (use "git merge --abort" to abort the merge)
        #
        # Unmerged paths:
        #   (use "git add <file>..." to mark resolution)
        #
        #       both modified:   content/chapter1.md
        #
        # no changes added to commit (use "git add" and/or "git commit -a")
      #+end_src
      but now we have /fixed the conflicts/. The next is to commit
      what we want the merge to be.

      #+begin_src shell-script
        git add content/chapter1.md
        git commit     # opens an editor with a default commit message
      #+end_src

#+REVEAL: split:t
      This merges the two branches and leaves us with the following history:
      #+begin_src shell-script
        git graph
        # *   57e9a39 - (32 seconds ago) Merge branch 'chapter1_alternative' into chapter1 (HEAD -> chapter1)
        # |\
        # | * 5521dc4 - (36 minutes ago) add phrase on how all glory of the world passes (chapter1_alternative)
        # * | fd6aadd - (42 minutes ago) add latin phrase on keeping contracts
        # |/
        # * dcf2ce3 - (2 weeks ago) change reason for being (tag: v0.0.1)
        # * 11cf9a1 - (2 weeks ago) continue work on chapter 1 (main)
      #+end_src

      Note how the history now makes a loop and is therefore not linear anymore.

#+REVEAL: split:t
      We can also have a look at this history using ~gitk --all~:

      #+name: fig:gitk_branches_after_merge
      #+caption: A successful merge shown in GUI of ~gitk --all~.
      [[file:figures/gitk_example_030_merge_two_branches.png]]

      Note that at this point, we might delete the alternative branch
      because we do not need it anymore:


      #+begin_src shell-script
        git branch -d chapter1_alternative
        # Deleted branch chapter1_alternative (was 5521dc4).
      #+end_src

#+REVEAL: split:t
***** A Comment on Mergetools

      There are tools available helping you with these
      conflicts. Personally, I only find them helpful in a limited set
      of problems, namely when the resolved situation is _either_ on
      _or_ the other branch (in our example: The resolved version
      should have been only one of the latin quotes). Therefore, I
      tend to resolve conflicts like above by manually going through
      these files.

      Should you want to have a look, then
      #+begin_src shell-script
        git merge ...
        # Auto-merging ...
        # CONFLICT (content): Merge conflict in ...
        # Automatic merge failed; fix conflicts and then commit the result.
        git mergetool --tool <toolname>   # Try TAB completion here
      #+end_src
      The corresponding tool will pop up and allow you to choose
      between A and B.

#+REVEAL: split:t
**** Trivial Merges / Rebases

     The good news is, that the above conflict situations are not very
     common.

     For example, if we are working on our /chapter2/, then
     #+begin_src shell-script
       git checkout chapter2
       echo '\nChapter 1 contained plenty of Latin quotes. Now we want to focus on something else' >> content/chapter2.md
       git commit -a -m 'add first lines to chapter 2'
       git graph
       # * bdab4b7 - (43 seconds ago) add first lines to chapter 2 (HEAD -> chapter2)
       # * ddd7afd - (2 weeks ago) add emtpy stub for chapter2
       # | *   57e9a39 - (19 minutes ago) Merge branch 'chapter1_alternative' into chapter1 (chapter1)
       # | |\
       # | | * 5521dc4 - (55 minutes ago) add phrase on how all glory of the world passes
       # | * | fd6aadd - (60 minutes ago) add latin phrase on keeping contracts
       # | |/
       # | * dcf2ce3 - (2 weeks ago) change reason for being (tag: v0.0.1)
       # | * 11cf9a1 - (2 weeks ago) continue work on chapter 1 (main)
       # |/
       # * 2218517 - (2 weeks ago) add gitignore file
     #+end_src

#+REVEAL: split:t
     So we could go back to the ~main~ branch and take both chapters
     into it:
     #+begin_src shell-script
       git checkout main
       git merge chapter1
       # Updating 11cf9a1..57e9a39
       # Fast-forward
       #  content/chapter1.md | 6 +++++-
       #  1 file changed, 5 insertions(+), 1 deletion(-)
     #+end_src
     This merge was called /fast-forward/ because ~chapter1~ was a
     direct descendant of ~main~ and git could just move it there:
     #+begin_src shell-script
       git graph
       # * bdab4b7 - (3 minutes ago) add first lines to chapter 2 (chapter2)
       # * ddd7afd - (2 weeks ago) add emtpy stub for chapter2
       # | *   57e9a39 - (21 minutes ago) Merge branch 'chapter1_alternative' into chapter1 (HEAD -> main, chapter1)
       # | |\
       # | | * 5521dc4 - (57 minutes ago) add phrase on how all glory of the world passes
     #+end_src

#+REVEAL: split:t
     We can now also include ~chapter2~. This is not a fsat-forward
     and we will be asked for a commit message:
     #+begin_src shell-script
       git merge chapter2       # asks for a commit message, we use the provided default
       # Merge made by the 'recursive' strategy.
       #  content/chapter2.md | 3 +++
       #  1 file changed, 3 insertions(+)
       #  create mode 100644 content/chapter2.md
     #+end_src

     For later reference, let us also set a new tag on this state:
     #+begin_src shell-script
       git tag -a -m 'Merge contents of chapter 1 and 2' v0.1.0
     #+end_src

#+REVEAL: split:t
     This leaves us with an even more non-linear history:
     #+begin_src shell-script
       git graph
       # *   e212d4f - (55 seconds ago) Merge branch 'chapter2' into main (HEAD -> main, tag: v0.1.0)
       # |\
       # | * bdab4b7 - (5 minutes ago) add first lines to chapter 2 (chapter2)
       # | * ddd7afd - (2 weeks ago) add emtpy stub for chapter2
       # * |   57e9a39 - (23 minutes ago) Merge branch 'chapter1_alternative' into chapter1 (chapter1)
       # |\ \
       # | * | 5521dc4 - (58 minutes ago) add phrase on how all glory of the world passes
       # * | | fd6aadd - (64 minutes ago) add latin phrase on keeping contracts
       # |/ /
       # * | dcf2ce3 - (2 weeks ago) change reason for being (tag: v0.0.1)
       # * | 11cf9a1 - (2 weeks ago) continue work on chapter 1
       # |/
       # * 2218517 - (2 weeks ago) add gitignore file
       # * e5d7d2b - (2 weeks ago) add latin phrases to chapter 1
       # * 51fe4ad - (2 weeks ago) add stub for chapter 1
       # * db30019 - (2 weeks ago) initial commit, add README.md
     #+end_src

#+REVEAL: split:t
     or in ~gitk --all~:

     #+name: fig:gitk_branches_after_merges_all
     #+caption: A successful no-conflict merge shown in GUI of ~gitk --all~.
     [[file:figures/gitk_example_040_merge_no_conflicts.png]]

     Note how this version ~v0.1.0~ came about without any need to
     resolve conflicts.

** Rebase Branches

   As mentioned above, there is an alternative way of getting
   information from separate branches together. While ~merge~ keeps
   the two branches as they are and tries to bundle them together at
   the top, ~rebase~ cuts off the second branch and places it on top
   of the other one.

   To see the difference, let's go back to our ~chapter1~ and
   ~chapter1_alternative~ examples. Note that branches are just names,
   think of them like variables. We can move them around without
   actually changing the underlying history of the commited work:
   #+begin_src shell-script
     git branch rebase_example_chapter1 fd6aadd
     git branch rebase_example_chapter1_alternative 5521dc4
   #+end_src
   This creates two new branches positioned at exactly the two points
   at which we did the above ~git merge~.

#+REVEAL: split:t
   We can display only the relevant bits with
   - ~gitk rebase_example_chapter1 rebase_example_chapter1_alternative~.

   #+name: fig:gitk_new_branches_before_rebase
   #+caption: Initial situation for a ~git rebase~
   [[file:figures/gitk_example_050_new_branches_for_rebase_example.png]]

#+REVEAL: split:t

   Instead of the above ~git merge chapter1_alternative~, which would
   bundle ~chapter1_alternative~ back into ~chapter1~, we detach
   ~chapter1_alternative~ from its branching point and re-attach it at
   ~chapter1~:

   #+begin_src shell-script
     # note that we checkout the "chapter1_alternaitve"
     # in the ~merge~ case we were at "chapter1"
     git checkout rebase_example_chapter1_alternative
     git rebase rebase_example_chapter1
     # First, rewinding head to replay your work on top of it...
     # Applying: add phrase on how all glory of the world passes
     # Using index info to reconstruct a base tree...
     # M	content/chapter1.md
     # Falling back to patching base and 3-way merge...
     # Auto-merging content/chapter1.md
     # CONFLICT (content): Merge conflict in content/chapter1.md
     # error: Failed to merge in the changes.
     # Patch failed at 0001 add phrase on how all glory of the world passes
     # Use 'git am --show-current-patch' to see the failed patch
     #
     # Resolve all conflicts manually, mark them as resolved with
     # "git add/rm <conflicted_files>", then run "git rebase --continue".
     # You can instead skip this commit: run "git rebase --skip".
     # To abort and get back to the state before "git rebase", run "git rebase --abort".
   #+end_src

#+REVEAL: split:t

   Like above with merge, you can abort this if you don't feel
   confident enough to decide what the resolved state should be:
   #+begin_src shell-script
     git rebase --abort
   #+end_src

   If, on the other hand, you want to go ahead, then we can see what
   is going on just like before: ~git diff~
   #+begin_src diff
diff --cc content/chapter1.md
index fc5a306,0736795..0000000
--- a/content/chapter1.md
+++ b/content/chapter1.md
@@@ -7,5 -7,5 +7,11 @@@ In dubio pro reo
  Quidquid latine dictum sit altum videtur.

  Per aspera ad astra
++<<<<<<< HEAD
 +
 +Pacta sunt servanda
++||||||| merged common ancestors
++=======
+
+ Sic transit gloria mundi
++>>>>>>> add phrase on how all glory of the world passes
   #+end_src

   Note that the markers ~<<<<<<<~, ~|||||||~, ~=======~, and
   ~>>>>>>>~ are the same as above.

#+REVEAL: split:t
   Like above, we can simply edit the file and get both latin phrases
   into the file. Once we have removed all the markers, we can
   #+begin_src shell-script
     git add content/chapter1.md
     git status
     # rebase in progress; onto fd6aadd
     # You are currently rebasing branch 'rebase_example_chapter1_alternative' on 'fd6aadd'.
     #   (all conflicts fixed: run "git rebase --continue")
     #
     # Changes to be committed:
     #   (use "git reset HEAD <file>..." to unstage)
     #
     #  modified:   content/chapter1.md
   #+end_src

   As the message suggests, you then continue with
   #+begin_src shell-script
     git rebase --continue
     # Applying: add phrase on how all glory of the world passes

     # we can examine the situation using
     gitk rebase_example_chapter1 rebase_example_chapter1_alternative
   #+end_src

#+REVEAL: split:t
   #+name: fig:gitk_new_branches_after_rebase
   #+caption: Situation after successful rebase
   [[file:figures/gitk_example_060_after_rebase_example.png]]

   Note how now the history is linear and we can simply
   #+begin_src shell-script
     git checkout rebase_example_chapter1
     # Switched to branch 'rebase_example_chapter1'
     git rebase rebase_example_chapter1_alternative
     # First, rewinding head to replay your work on top of it...
     # Fast-forwarded rebase_example_chapter1 to rebase_example_chapter1_alternative.
   #+end_src

#+REVEAL: split:t
   The content of the files here is exactly the same as after a
   ~merge~. But the underlying history is now linear instead of a
   diamond.

   There is a price to pay for this nice linearity: First, ~rebases~
   can be more difficult if they cover many commits as you might have
   to resolve conflicts for each of them while reabsing. Second, the
   rebased branch has different checksums after the rebase. This can
   break workflows if the state has already been published.

   So it is a good idea to only rebase local work.
